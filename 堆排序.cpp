#include<iostream>
// 选择排序算法思想：每一趟在带排序元素中选取关键字最小或最大的元素加入有序子序列
// 大根堆：完全二叉树中，根<=左、右
// 基于大根堆进行选择排序在选择最大的元素时非常方便，因为大根堆堆顶元素关键字最大
// 如何基于初始序列建立大根堆？思路：把所有非终端结点（i<=n/2）都检查一遍，看是否满足大根堆的要求，如果不满足，则进行调整
// 如何调整大根堆？思路：检查当前结点是否满足根>=左、右，若不满足，将当前结点与更大的一个孩子互换
// 若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断下坠）

// 建立大根堆，参数为初始序列A[]（从下标1开始存），序列长度len
void BuildMaxHeap(int A[],int len){
    // 从后往前逐个调整非终端结点
    for(int i=len/2;i>0;i--)
        HeadAdjust(A,i,len);
}

// 将所有以k为根的子树调整为大根堆
void HeadAdjust(int A[],int k,int len){
    // A[0]暂存子树的根节点A[k]
    A[0]=A[k];
    // 沿key值较大的子结点向下筛选
    for(int i=2*k;i<=len;i*=2){
        // i当前指向的左孩子，比较左右孩子key值，i指向key值较大的结点
        if(i<len&&A[i]<A[i+1]){
            // 右孩子key值更大
            i++;
        }
        // 比较k结点与i结点的key值，若A[k]>=A[i]，则不用调整以k为根的子树
        if(A[0]>=A[i]){
            // 不用调整子树，直接跳出循环
            break;
        }
        // A[k]<A[i]，根节点小于较大孩子，不满足大根堆
        else{
            // 将较大孩子A[i]调整到双亲结点上
            A[k]=A[i];
            // 修改k值，继续向下筛选
            k=i;
        }
    }
    // 筛选得到最终位置
    A[k]=A[0];
}

void swap(int &a,int &b){
    int temp;
    temp=a;
    a=b;
    b=temp;
}

// 堆排序
void HeapSort(int A[],int len){
    // 建立大根堆
    BuildMaxHeap(A,len);
    for(int i=len;i>1;i--){
        // 堆顶元素和堆底元素互换
        swap(A[i],A[1]);
        // 将剩余待排序元素调整为大根堆
        HeadAdjust(A,1,i-1);
    }
}
